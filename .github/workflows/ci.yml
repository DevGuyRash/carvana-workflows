name: CI

on:
  pull_request:
    paths:
      - "**/*.rs"
      - "**/Cargo.toml"
      - "**/Cargo.lock"
      - "**/deny.toml"
      - "**/rust-toolchain"
      - "**/rust-toolchain.toml"
      - ".github/workflows/**"
      - ".github/scripts/**"
  push:
    branches:
      - main
    paths:
      - "**/*.rs"
      - "**/Cargo.toml"
      - "**/Cargo.lock"
      - "**/deny.toml"
      - "**/rust-toolchain"
      - "**/rust-toolchain.toml"
      - ".github/workflows/**"
      - ".github/scripts/**"
  workflow_dispatch:

# Least-privilege default token scope for read-only CI checks.
permissions:
  contents: read

# Keep only truly harmless, universal defaults here.
env:
  CARGO_TERM_COLOR: always

concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true

jobs:
  detect-rust:
    name: Detect Rust workspaces
    runs-on: ubuntu-latest
    outputs:
      has_rust: ${{ steps.detect.outputs.has_rust }}
      matrix: ${{ steps.detect.outputs.matrix }}
    steps:
      - name: Checkout
        uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5 # v4

      # -----------------------------
      # Optional: cargo metadata (opt-in)
      # -----------------------------
      - name: Install Rust toolchain (opt-in for cargo metadata)
        if: env.CI_USE_CARGO_METADATA == 'true'
        uses: dtolnay/rust-toolchain@631a55b12751854ce901bb631d5902ceb48146f7 # stable

      - name: Detect Cargo workspaces/crates
        id: detect
        shell: bash
        run: |
          set -euo pipefail
          # Optional override:
          #   CI_USE_CARGO_METADATA=auto|true|false (default: auto)
          #   - auto: try cargo metadata if cargo is available, otherwise fall back
          #   - true: install Rust toolchain in this job, then try cargo metadata (fall back on failure)
          #   - false: skip cargo metadata
          #   CI_MANIFEST_EXCLUDE_DIRS=dir1,dir2 (optional extra manifest path exclusions)
          #   CI_MANIFEST_EXCLUDE_MODE=append|replace (default: append)
          #   CI_MAX_MATRIX_ENTRIES=<int> (default: 128; fail if exceeded)
          script_path=".github/scripts/detect_rust_workspaces.py"
          if [ ! -f "$script_path" ]; then
            echo "warning: missing detector script: $script_path" >&2
            # Keep this list aligned with detect_rust_workspaces.py default_excluded_dirs.
            fallback_manifest="$(
              find . \
                \( -path './.git' -o -path './.github' -o -path './.local' -o -path './target' -o -path './node_modules' -o -path './vendor' -o -path './tests' -o -path './test' -o -path './testdata' -o -path './fixtures' -o -path './fixture' -o -path './examples' -o -path './benches' -o -path './dist' -o -path './build' -o -path './out' \) -prune \
                -o -type f -name Cargo.toml -print -quit
            )"
            if [ -n "$fallback_manifest" ]; then
              echo "detector script is missing and Rust manifests are present; refusing to skip Rust CI" >&2
              exit 1
            fi
            echo "no Cargo.toml files detected in fallback scan; skipping Rust jobs" >&2
            {
              echo "has_rust=false"
              echo 'matrix={"include":[]}'
            } >> "$GITHUB_OUTPUT"
            exit 0
          fi
          python3 "$script_path"

  rust:
    name: Rust (fmt, clippy, test)
    needs: detect-rust
    if: needs.detect-rust.outputs.has_rust == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 45
    strategy:
      fail-fast: false
      matrix: ${{ fromJSON(needs.detect-rust.outputs.matrix) }}

    steps:
      - name: Checkout
        uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5 # v4

      # -----------------------------------------------------------------------
      # Config step: ALL toggles are opt-in via optional env vars, with defaults.
      # No workflow-level CI_* env required.
      # -----------------------------------------------------------------------
      - name: Configure CI knobs (defaults + auto-detection)
        id: cfg
        shell: bash
        working-directory: ${{ matrix.dir }}
        run: |
          set -euo pipefail

          # Optional overrides (set them only if you want):
          #   CI_RUN_FMT=true|false         (default: true)
          #   CI_RUN_CLIPPY=true|false      (default: true)
          #   CI_RUN_TESTS=true|false       (default: true)
          #   CI_RUN_VERIFY=true|false|auto (default: auto)
          #   CI_VERIFY_SCRIPT=<path>       (optional explicit override)
          #
          #   CI_ALL_FEATURES=true|false    (default: false)
          #   CI_LOCKED=auto|true|false     (default: auto)
          #   CI_CARGO_DENY=auto|true|false (default: auto)
          #   CI_CARGO_DENY_INSTALL=auto|true|false (default: auto)
          #
          #   CI_USE_MOLD=true|false        (default: false)
          #   CI_USE_SCCACHE=true|false     (default: false)

          run_fmt="${CI_RUN_FMT:-true}"
          run_clippy="${CI_RUN_CLIPPY:-true}"
          run_tests="${CI_RUN_TESTS:-true}"
          run_verify_mode="${CI_RUN_VERIFY:-auto}"

          all_features="${CI_ALL_FEATURES:-false}"
          locked_mode="${CI_LOCKED:-auto}"
          deny_mode="${CI_CARGO_DENY:-auto}"
          deny_install_mode="${CI_CARGO_DENY_INSTALL:-auto}"

          use_mold="${CI_USE_MOLD:-false}"
          use_sccache="${CI_USE_SCCACHE:-false}"
          repo_root="${GITHUB_WORKSPACE:-$(git rev-parse --show-toplevel 2>/dev/null || pwd)}"

          find_verify_script() {
            # Auto-discovery intentionally limits to the namespaced CI-owned
            # path to avoid executing unrelated project verify scripts.
            candidate="$repo_root/.github/scripts/verify.sh"
            if [ -f "$candidate" ]; then
              printf '%s\n' "$candidate"
              return 0
            fi
            return 1
          }

          resolve_verify_script_override() {
            override="${CI_VERIFY_SCRIPT:-}"
            if [ -z "$override" ]; then
              return 1
            fi

            case "$override" in
              /*) candidate="$override" ;;
              *) candidate="$repo_root/$override" ;;
            esac

            if [ -f "$candidate" ]; then
              printf '%s\n' "$candidate"
              return 0
            fi

            echo "CI_VERIFY_SCRIPT is set but does not exist: $candidate" >&2
            return 2
          }

          verify_script=""
          run_verify="false"
          case "$run_verify_mode" in
            true)
              if verify_script="$(resolve_verify_script_override)"; then
                run_verify="true"
              elif [ -n "${CI_VERIFY_SCRIPT:-}" ]; then
                exit 1
              elif verify_script="$(find_verify_script)"; then
                run_verify="true"
              else
                echo "CI_RUN_VERIFY=true but .github/scripts/verify.sh was not found (or set CI_VERIFY_SCRIPT)" >&2
                exit 1
              fi
              ;;
            false)
              run_verify="false"
              ;;
            auto|""|*)
              if [ "$run_verify_mode" != "auto" ] && [ -n "$run_verify_mode" ]; then
                echo "Unknown CI_RUN_VERIFY='$run_verify_mode' (expected auto|true|false); treating as auto" >&2
              fi
              if verify_script="$(resolve_verify_script_override)"; then
                run_verify="true"
              elif [ -n "${CI_VERIFY_SCRIPT:-}" ]; then
                exit 1
              elif verify_script="$(find_verify_script)"; then
                run_verify="true"
              fi
              ;;
          esac

          # Decide --locked dynamically if in auto mode.
          locked_flag=""
          case "$locked_mode" in
            true)  locked_flag="--locked" ;;
            false) locked_flag="" ;;
            auto|"")
              if [ -f Cargo.lock ]; then locked_flag="--locked"; fi
              ;;
            *)
              echo "Unknown CI_LOCKED='$locked_mode' (expected auto|true|false); treating as auto" >&2
              if [ -f Cargo.lock ]; then locked_flag="--locked"; fi
              ;;
          esac

          # Decide --workspace only when the root Cargo.toml is a workspace root.
          workspace_flag=""
          if [ "${{ matrix.is_workspace }}" = "true" ]; then
            workspace_flag="--workspace"
          fi

          # Decide --all-features only if explicitly enabled.
          features_flag=""
          if [ "$all_features" = "true" ]; then
            features_flag="--all-features"
          fi

          # Decide cargo-deny:
          # - true  => always run
          # - false => never run
          # - auto  => run only if deny.toml exists in this workspace root
          has_deny_toml="false"
          if [ -f deny.toml ]; then has_deny_toml="true"; fi

          run_deny="false"
          case "$deny_mode" in
            true)  run_deny="true" ;;
            false) run_deny="false" ;;
            auto|"")
              if [ "$has_deny_toml" = "true" ]; then run_deny="true"; fi
              ;;
            *)
              echo "Unknown CI_CARGO_DENY='$deny_mode' (expected auto|true|false); treating as auto" >&2
              if [ "$has_deny_toml" = "true" ]; then run_deny="true"; fi
              ;;
          esac

          # Decide whether CI may install cargo-deny in this matrix job.
          # The default is intentionally conservative to avoid repeated
          # per-job network installs.
          install_deny="false"
          case "$deny_install_mode" in
            true)  install_deny="true" ;;
            false|auto|"") install_deny="false" ;;
            *)
              echo "Unknown CI_CARGO_DENY_INSTALL='$deny_install_mode' (expected auto|true|false); treating as auto" >&2
              install_deny="false"
              ;;
          esac

          # Emit step outputs used by subsequent `if:` clauses.
          {
            echo "run_fmt=$run_fmt"
            echo "run_clippy=$run_clippy"
            echo "run_tests=$run_tests"
            echo "run_verify=$run_verify"
            echo "verify_script=$verify_script"
            echo "use_mold=$use_mold"
            echo "use_sccache=$use_sccache"
            echo "run_deny=$run_deny"
            echo "deny_mode=$deny_mode"
            echo "install_deny=$install_deny"
            echo "workspace_flag=$workspace_flag"
            echo "features_flag=$features_flag"
            echo "locked_flag=$locked_flag"
          } >> "$GITHUB_OUTPUT"

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@631a55b12751854ce901bb631d5902ceb48146f7 # stable
        with:
          components: rustfmt, clippy

      # -----------------------------
      # Optional: mold (opt-in)
      # -----------------------------
      - name: Install mold (opt-in)
        if: steps.cfg.outputs.use_mold == 'true'
        uses: rui314/setup-mold@725a8794d15fc7563f59595bd9556495c0564878 # v1

      - name: Enable mold linker (opt-in, best-effort)
        if: steps.cfg.outputs.use_mold == 'true'
        shell: bash
        run: |
          set -euo pipefail
          if command -v mold >/dev/null 2>&1; then
            echo "RUSTFLAGS=${RUSTFLAGS:+$RUSTFLAGS }-C link-arg=-fuse-ld=mold" >> "$GITHUB_ENV"
          else
            echo "mold not found; continuing without it"
          fi

      # -----------------------------
      # Optional: sccache (opt-in)
      # -----------------------------
      - name: Install sccache (opt-in)
        if: steps.cfg.outputs.use_sccache == 'true'
        uses: mozilla-actions/sccache-action@7d986dd989559c6ecdb630a3fd2557667be217ad # v0.0.9

      - name: Start sccache (opt-in, best-effort)
        if: steps.cfg.outputs.use_sccache == 'true'
        shell: bash
        run: |
          set +e

          export SCCACHE_GHA_ENABLED="true"
          export SCCACHE_CACHE_SIZE="2G"

          sccache --stop-server >/dev/null 2>&1 || true
          sccache --start-server
          status=$?

          if [ $status -ne 0 ]; then
            echo "sccache GH cache unavailable; retrying local-only"
            sccache --stop-server >/dev/null 2>&1 || true
            SCCACHE_GHA_ENABLED=false sccache --start-server
            status=$?
          fi

          if [ $status -ne 0 ]; then
            echo "sccache unavailable; continuing without it"
            echo "RUSTC_WRAPPER=" >> "$GITHUB_ENV"
            echo "SCCACHE_DISABLE=1" >> "$GITHUB_ENV"
          else
            echo "RUSTC_WRAPPER=sccache" >> "$GITHUB_ENV"
            if [ "${SCCACHE_GHA_ENABLED}" != "true" ]; then
              echo "SCCACHE_GHA_ENABLED=false" >> "$GITHUB_ENV"
            fi
          fi

      - name: Rust cache
        uses: Swatinem/rust-cache@779680da715d629ac1d338a641029a2f4372abb5 # v2
        with:
          workspaces: ${{ matrix.dir }}

      - name: Prepare diagnostics directory
        shell: bash
        env:
          MATRIX_DIR: ${{ matrix.dir }}
        run: |
          set -euo pipefail
          diag_dir="$RUNNER_TEMP/rust-ci/$MATRIX_DIR"
          mkdir -p "$diag_dir"
          echo "RUST_CI_DIAG_DIR=$diag_dir" >> "$GITHUB_ENV"

      - name: Rust fmt
        if: steps.cfg.outputs.run_fmt == 'true'
        working-directory: ${{ matrix.dir }}
        shell: bash
        run: |
          set -euo pipefail
          cargo fmt --all --check 2>&1 | tee "$RUST_CI_DIAG_DIR/rust-fmt.log"

      - name: Rust clippy
        if: steps.cfg.outputs.run_clippy == 'true'
        working-directory: ${{ matrix.dir }}
        shell: bash
        run: |
          set -euo pipefail
          cargo clippy \
            ${{ steps.cfg.outputs.workspace_flag }} \
            --all-targets \
            ${{ steps.cfg.outputs.features_flag }} \
            ${{ steps.cfg.outputs.locked_flag }} \
            -- \
            -D warnings 2>&1 | tee "$RUST_CI_DIAG_DIR/rust-clippy.log"

      - name: Rust tests
        if: steps.cfg.outputs.run_tests == 'true'
        working-directory: ${{ matrix.dir }}
        shell: bash
        run: |
          set -euo pipefail
          cargo test \
            ${{ steps.cfg.outputs.workspace_flag }} \
            --all-targets \
            ${{ steps.cfg.outputs.features_flag }} \
            ${{ steps.cfg.outputs.locked_flag }} 2>&1 | tee "$RUST_CI_DIAG_DIR/rust-test.log"


      # -----------------------------------------------------------------------
      # Banned-pattern scan via verify.sh (optional; runs if script exists)
      # CI_RUN_VERIFY=true|false|auto (default: auto â€” runs only when
      # .github/scripts/verify.sh is present)
      # CI_VERIFY_SCRIPT optionally overrides the verify script path.
      # -----------------------------------------------------------------------
      - name: Banned-pattern scan
        if: steps.cfg.outputs.run_verify == 'true'
        working-directory: ${{ matrix.dir }}
        shell: bash
        env:
          # Keep verify focused on installation + banned-pattern checks; fmt/clippy/tests
          # are already enforced by dedicated CI steps in this job.
          VERIFY_RUN_FMT: "false"
          VERIFY_RUN_CLIPPY: "false"
          VERIFY_RUN_TESTS: "false"
        run: |
          set -euo pipefail
          repo_root="${GITHUB_WORKSPACE:-$(git rev-parse --show-toplevel 2>/dev/null || pwd)}"
          verify_script="${{ steps.cfg.outputs.verify_script }}"
          if [ -z "$verify_script" ]; then
            echo "verify.sh not found but CI_RUN_VERIFY resolved to true" >&2
            exit 1
          fi
          if [ ! -f "$verify_script" ]; then
            echo "verify.sh path from cfg step is not a file: $verify_script" >&2
            exit 1
          fi
          case "$verify_script" in
            "$repo_root"/*) ;;
            *)
              echo "verify.sh path from cfg step is outside repository root: $verify_script" >&2
              exit 1
              ;;
          esac
          echo "Running banned-pattern scan via $verify_script"
          bash "$verify_script" 2>&1 | tee "$RUST_CI_DIAG_DIR/verify.log"

      - name: Install cargo-deny (optional; prebuilt)
        if: steps.cfg.outputs.run_deny == 'true' && steps.cfg.outputs.install_deny == 'true'
        uses: taiki-e/install-action@cfdb446e391c69574ebc316dfb7d7849ec12b940 # v2
        with:
          tool: cargo-deny

      - name: Cargo deny (optional; auto if deny.toml exists)
        if: steps.cfg.outputs.run_deny == 'true'
        working-directory: ${{ matrix.dir }}
        shell: bash
        run: |
          set -euo pipefail
          if ! command -v cargo-deny >/dev/null 2>&1; then
            if [ "${{ steps.cfg.outputs.deny_mode }}" = "true" ]; then
              echo "CI_CARGO_DENY=true but cargo-deny is unavailable and CI_CARGO_DENY_INSTALL is not true" >&2
              exit 1
            else
              echo "cargo-deny unavailable; skipping deny check (set CI_CARGO_DENY_INSTALL=true to allow install)"
              exit 0
            fi
          fi
          cargo deny check

      - name: Upload Rust diagnostics
        if: always()
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4.6.2
        with:
          name: rust-ci-logs-${{ strategy.job-index }}
          path: ${{ env.RUST_CI_DIAG_DIR }}/*.log
          if-no-files-found: ignore
