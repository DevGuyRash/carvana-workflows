This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.
The content has been processed where line numbers have been added.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: dist, packages, scripts, .gitignore, AGENTS.md, package-lock.json, package.json, README.md, repomix-output.xml, tsconfig.base.json, tsconfig.json, vitest.config.ts
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Line numbers have been added to the beginning of each line
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitignore
AGENTS.md
package.json
packages/core/package.json
packages/core/src/clipboard.ts
packages/core/src/data.ts
packages/core/src/index.ts
packages/core/src/logger.ts
packages/core/src/selector.ts
packages/core/src/storage.ts
packages/core/src/templating.ts
packages/core/src/types.ts
packages/core/src/ui.ts
packages/core/src/utils.ts
packages/core/src/wait.ts
packages/core/src/workflow.ts
packages/core/test/extractList.test.ts
packages/core/test/selector.test.ts
packages/core/test/templating.test.ts
packages/jira-userscript/metadata.json
packages/jira-userscript/package.json
packages/jira-userscript/src/index.ts
packages/jira-userscript/src/pages/fallback-demo.ts
packages/oracle-userscript/metadata.json
packages/oracle-userscript/package.json
packages/oracle-userscript/src/index.ts
packages/oracle-userscript/src/pages/fallback-demo.ts
README.md
scripts/build.mjs
tsconfig.base.json
tsconfig.json
vitest.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".gitignore">
 1: # dependencies
 2: node_modules/
 3: pnpm-lock.yaml
 4: yarn.lock
 5: package-lock.json
 6: 
 7: # builds
 8: dist/
 9: packages/*/dist/
10: 
11: # logs
12: npm-debug.log*
13: yarn-debug.log*
14: yarn-error.log*
15: *.log
16: 
17: # OS/editor
18: .DS_Store
19: Thumbs.db
20: .vscode/
21: .idea/
22: 
23: # misc
24: *.local.*
25: .env
</file>

<file path="AGENTS.md">
  1: # AGENTS.md — Carvana Userscripts: Authoring & Extensibility Guide
  2: 
  3: This document is the hands-on guide for building and evolving automations (pages, workflows, steps) on top of the foundation. It complements `README.md` (which stays short).
  4: 
  5: ---
  6: 
  7: ## Core Concepts
  8: 
  9: - **Page**: A detectable surface (e.g., “Jira – Issue View”). Pages have a `detector` (conditions) and a list of **workflows**.
 10: - **Workflow**: A sequence of **actions** (click/type/wait/extract/branch/error). You can persist and resume.
 11: - **Selectors**: Robust, composable definitions (`SelectorSpec`) that locate elements without brittleness.
 12: - **Engine**: Runs workflows, stores last step/workflow, and integrates with the menu.
 13: - **Menu**: A Shadow‑DOM panel with tabs (Workflows, Selectors, Theme, Storage, Logs). You can edit selectors at runtime.
 14: 
 15: ---
 16: 
 17: ## SelectorSpec (robust selection)
 18: 
 19: Available fields (you can combine them):
 20: 
 21: - `selector` (CSS), `id`, `tag`, `type`, `role`
 22: - `text` { `equals` | `includes` | `regex` } with `caseInsensitive`, `trim`
 23: - `attribute`: object of attribute matchers with `equals/includes/regex`
 24: - `visible`: require visibility
 25: - `within`: scope to an ancestor that matches another `SelectorSpec`
 26: - Logical: `and`, `or`, `not`
 27: - `nth`: choose an index (0‑based)
 28: 
 29: **Tip:** Prefer combinations (e.g., `role + text.includes + attribute`) over brittle CSS.
 30: 
 31: ---
 32: 
 33: ## Actions DSL
 34: 
 35: - `waitFor` — wait for element by selector; supports `timeoutMs`, `visibleOnly`, `minStabilityMs`.
 36: - `delay` — sleep for ms.
 37: - `click` — optional `preWait`, `postWaitFor` (e.g., wait for a listbox that opens).
 38: - `type` — `clearFirst`, per‑key delay, optional `postEnter`.
 39: - `selectFromList` — pick an item in a popup/list using list spec + item spec.
 40: - `extract` — harvest `text/html/value/href/attribute` into a JSON object; `present` to show; `copyToClipboard` to copy.
 41: - `branch` — conditional routing (`exists/notExists/textPresent/any/all/not`) to another workflow ID.
 42: - `error` — display a message (can be used in error workflows).
 43: 
 44: You can add new actions; see **“Adding a new Action”** below.
 45: 
 46: ---
 47: 
 48: ## Adding a Page
 49: 
 50: Create a file like `packages/jira-userscript/src/pages/my-page.ts`:
 51: 
 52: ```ts
 53: import type { PageDefinition, WorkflowDefinition } from '@cv/core';
 54: 
 55: export const MyPage: PageDefinition = {
 56:   id: 'jira.my.page',
 57:   label: 'Jira — My Custom Page',
 58:   detector: {
 59:     all: [
 60:       { exists: { selector: 'body' } },
 61:       { textPresent: { where: { selector: 'h1, [data-test-id="page-title"]' }, matcher: { includes: 'My Page', caseInsensitive: true } } }
 62:     ]
 63:   },
 64:   workflows: []
 65: };
 66: 
 67: const MyWorkflow: WorkflowDefinition = {
 68:   id: 'jira.my.do.something',
 69:   label: 'Do Something',
 70:   steps: [
 71:     { kind: 'click', target: { text: { includes: 'Open Menu', caseInsensitive: true }, tag: 'button' }, postWaitFor: { role: 'listbox' } },
 72:     { kind: 'selectFromList', list: { role: 'listbox' }, item: { text: { equals: 'Desired Item', caseInsensitive: true } } }
 73:   ]
 74: };
 75: 
 76: MyPage.workflows.push(MyWorkflow);
 77: ```
 78: 
 79: Register the page in your `src/index.ts` (order matters: first match wins) and rebuild.
 80: 
 81: ---
 82: 
 83: ## Authoring a Workflow
 84: 
 85: * Start with a rough flow using generic selectors (or just text), then open **Menu → Selectors** to refine.
 86: * Use `postWaitFor` on `click` when the click opens a panel/list/etc.
 87: * Use `waitFor` when you need to wait for contents to appear.
 88: * Use `branch` to handle missing elements or alternate paths.
 89: * Use `extract` + `present` for quick UI feedback, and `copyToClipboard` to move data to your clipboard.
 90: 
 91: ---
 92: 
 93: ## Loading States (no guessing)
 94: 
 95: If Oracle (or any page) has a “loading” element, persist it in Settings:
 96: 
 97: ```json
 98: {
 99:   "theme": { "primary": "#1f7a8c", "background": "#0b0c10e6", "text": "#f5f7fb", "accent": "#ffbd59" },
100:   "interActionDelayMs": 120,
101:   "loadingIndicator": { "selector": ".af_busy", "visible": true }
102: }
103: ```
104: 
105: When set, the engine waits after every step until that element is no longer visible.
106: 
107: ---
108: 
109: ## Branching & Error Paths
110: 
111: Route to other workflows:
112: 
113: ```ts
114: { kind: 'branch',
115:   condition: { notExists: { selector: '[data-field-id="resolution"] [data-testid="single-select-read-view"]' } },
116:   thenWorkflow: 'jira.set.resolution',
117:   elseWorkflow: 'jira.already.ok'
118: }
119: ```
120: 
121: This executes nested workflows safely.
122: 
123: ---
124: 
125: ## Persistent Memory
126: 
127: Engine stores:
128: 
129: * `lastWorkflow` (id + timestamp)
130: * `lastStep` (index)
131: * Config and selectors via `Store` (GM_*), export/import in **Storage** tab.
132: 
133: You can store arbitrary KV per workflow if you need it (extend in your actions).
134: 
135: ---
136: 
137: ## Adding a New Action (advanced)
138: 
139: 1. Extend the `Action` union in `packages/core/src/types.ts`:
140: 
141: ```ts
142: | { kind: 'focus'; target: SelectorSpec; comment?: string }
143: ```
144: 
145: 2. Implement in `execStep` in `packages/core/src/workflow.ts`:
146: 
147: ```ts
148: case 'focus': {
149:   const el = findOne(step.target, { visibleOnly: true }) as HTMLElement | null;
150:   if (!el) return { ok: false, error: 'focus: target not found' };
151:   el.focus();
152:   return { ok: true };
153: }
154: ```
155: 
156: Rebuild and reinstall.
157: 
158: ---
159: 
160: ## Testing & Debugging
161: 
162: * Use the **Demo** workflows first to verify plumbing (copy title/info).
163: * Use **Selectors → Test Match** to highlight current selector matches.
164: * If the menu isn’t visible, ensure your userscript is enabled and the URL matches your `@match`.
165: * If a page doesn’t show expected workflows, your **detector** likely didn’t match. Temporarily switch to a fallback demo page or relax your detector.
166: * Use browser devtools + Console for logs.
167: 
168: ---
169: 
170: ## Style & Principles
171: 
172: * **DRY, SOLID, KISS, YAGNI** across workflows and selectors.
173: * Prefer semantic attributes, roles, and text over brittle positional CSS.
174: * Keep workflows small, composable, and data‑driven (selectors and values in settings/storage where possible).
</file>

<file path="package.json">
 1: {
 2:   "name": "cv-userscripts-foundation",
 3:   "version": "0.1.0",
 4:   "private": true,
 5:   "workspaces": [
 6:     "packages/*"
 7:   ],
 8:   "scripts": {
 9:     "build": "node scripts/build.mjs",
10:     "clean": "rimraf dist && rimraf packages/*/dist",
11:     "typecheck": "tsc -b",
12:     "test": "vitest run",
13:     "test:watch": "vitest"
14:   },
15:   "devDependencies": {
16:     "@types/tampermonkey": "^5.0.4",
17:     "esbuild": "^0.25.11",
18:     "rimraf": "^5.0.5",
19:     "typescript": "^5.6.3",
20:     "vitest": "^2.1.1",
21:     "jsdom": "^25.0.0"
22:   }
23: }
</file>

<file path="packages/core/package.json">
1: {
2:   "name": "@cv/core",
3:   "version": "0.1.0",
4:   "private": true,
5:   "type": "module"
6: }
</file>

<file path="packages/core/src/clipboard.ts">
1: /* global GM_setClipboard */
2: export function copy(text: string){
3:   GM_setClipboard(text, { type: 'text', mimetype: 'text/plain' });
4: }
</file>

<file path="packages/core/src/data.ts">
 1: import type { SelectorSpec, TakeSpec } from './types';
 2: import { findAll, findOne } from './selector';
 3: 
 4: export function takeFromElement(el: Element, take: TakeSpec|undefined): string {
 5:   const t = take ?? 'text';
 6:   if (t === 'text') return (el.textContent || '').trim();
 7:   if (t === 'html') return (el as HTMLElement).innerHTML;
 8:   if (t === 'value') return (el as HTMLInputElement).value || '';
 9:   if (t === 'href') return (el as HTMLAnchorElement).href || '';
10:   if (t === 'raw')  return (el as any).textContent ?? '';
11:   if (typeof t === 'object' && 'attribute' in t) return el.getAttribute(t.attribute) || '';
12:   return '';
13: }
14: 
15: /** Extract up to `limit` items using a base list selector and per-field specs. */
16: export function extractListData(
17:   list: SelectorSpec,
18:   fields: { key: string; take: TakeSpec; from?: SelectorSpec }[],
19:   limit = 20,
20:   opts?: { visibleOnly?: boolean }
21: ): Record<string, string>[] {
22:   const rows = findAll(list, { visibleOnly: !!opts?.visibleOnly });
23:   const out: Record<string, string>[] = [];
24:   for (let i=0; i<rows.length && i<limit; i++){
25:     const row = rows[i];
26:     const obj: Record<string, string> = {};
27:     for (const f of fields){
28:       const target = f.from ? (findOne(f.from, { root: row, visibleOnly: !!opts?.visibleOnly }) ?? row) : row;
29:       if (!target) { obj[f.key] = ''; continue; }
30:       obj[f.key] = takeFromElement(target, f.take);
31:     }
32:     out.push(obj);
33:   }
34:   return out;
35: }
</file>

<file path="packages/core/src/index.ts">
 1: export * from './types';
 2: export * from './utils';
 3: export * from './selector';
 4: export * from './wait';
 5: export * from './storage';
 6: export * from './clipboard';
 7: export * from './logger';
 8: export * from './ui';
 9: export * from './workflow';
10: export * from './templating';
11: export * from './data';
</file>

<file path="packages/core/src/logger.ts">
 1: export class Logger {
 2:   history: { ts: number; level: 'debug'|'info'|'warn'|'error'; message: string }[] = [];
 3:   constructor(public prefix='CV'){
 4:   }
 5:   private push(level: 'debug'|'info'|'warn'|'error', message: string){
 6:     this.history.push({ ts: Date.now(), level, message });
 7:     // eslint-disable-next-line no-console
 8:     console[level](`[${this.prefix}] ${message}`);
 9:   }
10:   debug(m: string){ this.push('debug', m); }
11:   info(m: string){ this.push('info', m); }
12:   warn(m: string){ this.push('warn', m); }
13:   error(m: string){ this.push('error', m); }
14: }
</file>

<file path="packages/core/src/selector.ts">
  1: import type { AttributeMatcher, SelectorSpec, TextMatcher } from './types';
  2: import { asArray, isVisible, normalizeWhitespace, toRegExp } from './utils';
  3: 
  4: function matchesText(text: string, matcher: TextMatcher): boolean {
  5:   const t = 'trim' in matcher && matcher.trim ? normalizeWhitespace(text) : text;
  6:   if ('equals' in matcher) {
  7:     return matcher.caseInsensitive ? t.toLowerCase() === matcher.equals.toLowerCase() : t === matcher.equals;
  8:   }
  9:   if ('includes' in matcher) {
 10:     return matcher.caseInsensitive ? t.toLowerCase().includes(matcher.includes.toLowerCase()) : t.includes(matcher.includes);
 11:   }
 12:   if ('regex' in matcher) {
 13:     const re = toRegExp(matcher); if (!re) return false; return re.test(t);
 14:   }
 15:   return false;
 16: }
 17: 
 18: function matchesAttr(value: string|null, matcher: AttributeMatcher): boolean {
 19:   if (value == null) return false;
 20:   if (typeof matcher === 'string') return value === matcher;
 21:   if (matcher.equals != null) return value === matcher.equals;
 22:   if (matcher.includes != null) return value.includes(matcher.includes);
 23:   if (matcher.regex != null) {
 24:     const re = new RegExp(matcher.regex, matcher.flags);
 25:     return re.test(value);
 26:   }
 27:   return false;
 28: }
 29: 
 30: function candidateSet(root: Document|Element, spec: SelectorSpec): Element[] {
 31:   // Prefer CSS selector or id to narrow candidates
 32:   if (spec.selector) return Array.from(root.querySelectorAll(spec.selector));
 33:   if (spec.id) {
 34:     const el = (root instanceof Document ? root : root.ownerDocument!).getElementById(spec.id);
 35:     return el ? [el] : [];
 36:   }
 37:   if (spec.tag) return Array.from(root.getElementsByTagName(spec.tag));
 38:   if (spec.role) return Array.from(root.querySelectorAll(`[role="${spec.role}"]`));
 39:   // Fallback: full scan (kept efficient via TreeWalker)
 40:   const walker = (root instanceof Document ? root : root.ownerDocument!).createTreeWalker(
 41:     root, NodeFilter.SHOW_ELEMENT, null
 42:   );
 43:   const els: Element[] = [];
 44:   let n: Node|null;
 45:   while ((n = walker.nextNode())) els.push(n as Element);
 46:   return els;
 47: }
 48: 
 49: function _matches(el: Element, spec: SelectorSpec): boolean {
 50:   if (spec.selector && !el.matches(spec.selector)) return false;
 51:   if (spec.id && (el as HTMLElement).id !== spec.id) return false;
 52:   if (spec.tag && el.tagName.toLowerCase() !== spec.tag.toLowerCase()) return false;
 53:   if (spec.type) {
 54:     const t = (el as HTMLInputElement).type?.toLowerCase() || el.getAttribute('type')?.toLowerCase();
 55:     if (t !== spec.type.toLowerCase()) return false;
 56:   }
 57:   if (spec.role) {
 58:     const r = el.getAttribute('role');
 59:     if (r !== spec.role) return false;
 60:   }
 61:   if (spec.attribute) {
 62:     for (const [k, v] of Object.entries(spec.attribute)) {
 63:       const val = el.getAttribute(k);
 64:       if (!matchesAttr(val, v)) return false;
 65:     }
 66:   }
 67:   if (spec.text) {
 68:     const t = (el.textContent || '').trim();
 69:     if (!matchesText(t, spec.text)) return false;
 70:   }
 71:   if (spec.visible && !isVisible(el)) return false;
 72:   if (spec.within) {
 73:     let p: Element|null = el.parentElement;
 74:     let ok = false;
 75:     while (p) {
 76:       if (_matches(p, spec.within)) { ok = true; break; }
 77:       p = p.parentElement;
 78:     }
 79:     if (!ok) return false;
 80:   }
 81:   if (spec.and) {
 82:     for (const sub of spec.and) if (!_matches(el, sub)) return false;
 83:   }
 84:   if (spec.or) {
 85:     let ok = false;
 86:     for (const sub of spec.or) { if (_matches(el, sub)) { ok = true; break; } }
 87:     if (!ok) return false;
 88:   }
 89:   if (spec.not) {
 90:     if (_matches(el, spec.not)) return false;
 91:   }
 92:   return true;
 93: }
 94: 
 95: export function findAll(spec: SelectorSpec, opts?: { root?: Document|Element; visibleOnly?: boolean }): Element[] {
 96:   const root = opts?.root ?? document;
 97:   const cands = candidateSet(root, spec);
 98:   const out: Element[] = [];
 99:   for (const el of cands) {
100:     if (_matches(el, spec) && (!opts?.visibleOnly || isVisible(el))) out.push(el);
101:   }
102:   return out;
103: }
104: 
105: export function findOne(spec: SelectorSpec, opts?: { root?: Document|Element; visibleOnly?: boolean }): Element | null {
106:   const all = findAll(spec, opts);
107:   if (all.length === 0) return null;
108:   if (spec.nth != null) return all[spec.nth] ?? null;
109:   return all[0];
110: }
111: 
112: export function highlight(elements: Element[], ms = 800){
113:   const doc = elements[0]?.ownerDocument || document;
114:   for (const el of elements) {
115:     const old = el.getAttribute('data-cv-highlight');
116:     if (old) continue;
117:     el.setAttribute('data-cv-highlight', '1');
118:     const prevOutline = (el as HTMLElement).style.outline;
119:     (el as HTMLElement).style.outline = '3px solid #2ecc71';
120:     setTimeout(() => {
121:       (el as HTMLElement).style.outline = prevOutline;
122:       el.removeAttribute('data-cv-highlight');
123:     }, ms);
124:   }
125: }
</file>

<file path="packages/core/src/storage.ts">
 1: /**
 2:  * Storage via GM_* with namespacing.
 3:  */
 4: /* global GM_getValue, GM_setValue, GM_listValues, GM_deleteValue */
 5: export class Store {
 6:   private ns: string;
 7:   constructor(namespace: string){
 8:     this.ns = namespace;
 9:   }
10:   private k(key: string){ return `${this.ns}:${key}`; }
11: 
12:   get<T>(key: string, fallback: T): T {
13:     try {
14:       const raw = GM_getValue(this.k(key));
15:       if (raw == null) return fallback;
16:       return JSON.parse(String(raw));
17:     } catch {
18:       return fallback;
19:     }
20:   }
21: 
22:   set<T>(key: string, value: T){
23:     GM_setValue(this.k(key), JSON.stringify(value));
24:   }
25: 
26:   delete(key: string){
27:     GM_deleteValue(this.k(key));
28:   }
29: 
30:   keys(): string[]{
31:     const all = GM_listValues();
32:     return all.filter(k => k.startsWith(`${this.ns}:`)).map(k => k.slice(this.ns.length + 1));
33:   }
34: 
35:   exportAll(): Record<string, any> {
36:     const out: Record<string, any> = {};
37:     for (const k of this.keys()){
38:       out[k] = this.get(k, null);
39:     }
40:     return out;
41:   }
42: 
43:   importAll(obj: Record<string, any>){
44:     for (const [k, v] of Object.entries(obj)){
45:       this.set(k, v);
46:     }
47:   }
48: }
</file>

<file path="packages/core/src/templating.ts">
 1: export function getByPath(obj: any, path: string): any {
 2:   const parts = path.split('.').map(s => s.trim()).filter(Boolean);
 3:   let cur = obj;
 4:   for (const p of parts) {
 5:     if (cur == null) return undefined;
 6:     cur = cur[p];
 7:   }
 8:   return cur;
 9: }
10: 
11: /** Replace {{ path }} occurrences with values from ctx (e.g. ctx.opt.maxLinks). */
12: export function renderTemplate(str: string, ctx: Record<string, any>): string {
13:   return str.replace(/\{\{\s*([^}]+?)\s*\}\}/g, (_m, g1) => {
14:     const val = getByPath(ctx, g1);
15:     return val == null ? '' : String(val);
16:   });
17: }
18: 
19: /** Deeply walk any object/array and template all string leaves. */
20: export function deepRenderTemplates<T>(value: T, ctx: Record<string, any>): T {
21:   if (typeof value === 'string') return renderTemplate(value, ctx) as unknown as T;
22:   if (Array.isArray(value)) return value.map(v => deepRenderTemplates(v, ctx)) as unknown as T;
23:   if (value && typeof value === 'object') {
24:     const out: any = Array.isArray(value) ? [] : {};
25:     for (const [k, v] of Object.entries(value as any)) {
26:       out[k] = deepRenderTemplates(v, ctx);
27:     }
28:     return out;
29:   }
30:   return value;
31: }
</file>

<file path="packages/core/src/types.ts">
  1: /**
  2:  * Shared types for selector specs, waits, actions, workflows, and settings.
  3:  */
  4: 
  5: export type TextMatcher =
  6:   | { equals: string; caseInsensitive?: boolean; trim?: boolean }
  7:   | { includes: string; caseInsensitive?: boolean; trim?: boolean }
  8:   | { regex: string; flags?: string; trim?: boolean };
  9: 
 10: export type AttributeMatcher =
 11:   | string
 12:   | { equals?: string; includes?: string; regex?: string; flags?: string };
 13: 
 14: export interface SelectorSpec {
 15:   selector?: string;
 16:   id?: string;
 17:   text?: TextMatcher;
 18:   attribute?: Record<string, AttributeMatcher>;
 19:   role?: string;
 20:   tag?: string;
 21:   type?: string;
 22:   visible?: boolean;
 23:   within?: SelectorSpec;
 24:   and?: SelectorSpec[];
 25:   or?: SelectorSpec[];
 26:   not?: SelectorSpec;
 27:   nth?: number;
 28: }
 29: 
 30: /** Read globals safely (no DOM selection). */
 31: export type GlobalKey =
 32:   | 'document.title'
 33:   | 'location.href'
 34:   | 'location.host'
 35:   | 'location.pathname'
 36:   | 'navigator.userAgent'
 37:   | 'timestamp';
 38: 
 39: export interface GlobalSource {
 40:   global: GlobalKey;
 41: }
 42: 
 43: export type SourceSpec = SelectorSpec | GlobalSource;
 44: 
 45: export interface WaitOptions {
 46:   timeoutMs?: number;
 47:   pollIntervalMs?: number;
 48:   visibleOnly?: boolean;
 49:   minStabilityMs?: number;
 50: }
 51: 
 52: export type ConditionSpec =
 53:   | { exists: SelectorSpec }
 54:   | { notExists: SelectorSpec }
 55:   | { textPresent: { where: SelectorSpec; matcher: TextMatcher } }
 56:   | { any: ConditionSpec[] }
 57:   | { all: ConditionSpec[] }
 58:   | { not: ConditionSpec };
 59: 
 60: export type ActionResult =
 61:   | { ok: true; data?: any }
 62:   | { ok: false; error: string; details?: any };
 63: 
 64: /** Options (params) a workflow can expose and persist. */
 65: export type WorkflowOption =
 66:   | { key: string; label: string; type: 'string'; default?: string }
 67:   | { key: string; label: string; type: 'number'; default?: number }
 68:   | { key: string; label: string; type: 'boolean'; default?: boolean }
 69:   | { key: string; label: string; type: 'select'; default?: string; choices: { value: string; label: string }[] }
 70:   | { key: string; label: string; type: 'multi'; default?: string[]; hint?: string }  // newline-separated textarea
 71:   | { key: string; label: string; type: 'json'; default?: any };
 72: 
 73: export type TakeSpec = 'text'|'html'|'value'|'href'|{attribute: string}|'raw';
 74: 
 75: export type Action =
 76:   | { kind: 'waitFor'; target: SelectorSpec; wait?: WaitOptions; comment?: string }
 77:   | { kind: 'delay'; ms: number; comment?: string }
 78:   | { kind: 'click'; target: SelectorSpec; preWait?: WaitOptions; postWaitFor?: SelectorSpec; comment?: string }
 79:   | { kind: 'type'; target: SelectorSpec; text: string; clearFirst?: boolean; perKeystrokeDelayMs?: number; postEnter?: boolean; comment?: string }
 80:   | { kind: 'selectFromList'; list: SelectorSpec; item: SelectorSpec; comment?: string }
 81:   | { kind: 'extract'; items: { from: SourceSpec; take?: TakeSpec; intoKey: string }[]; copyToClipboard?: boolean; present?: boolean; comment?: string }
 82:   | { kind: 'extractList';
 83:       list: SelectorSpec;
 84:       fields: { key: string; take: TakeSpec; from?: SelectorSpec }[];
 85:       intoKey: string;
 86:       limit?: number|string; // allow templating -> string
 87:       visibleOnly?: boolean;
 88:       copyToClipboard?: boolean;
 89:       present?: boolean;
 90:       comment?: string;
 91:     }
 92:   | { kind: 'branch'; condition: ConditionSpec; thenWorkflow: string; elseWorkflow?: string; comment?: string }
 93:   | { kind: 'error'; message: string; comment?: string };
 94: 
 95: export interface WorkflowDefinition {
 96:   id: string;
 97:   label: string;
 98:   description?: string;
 99:   enabledWhen?: ConditionSpec;
100:   steps: Action[];
101:   /** Persisted options available as {{opt.KEY}} */
102:   options?: WorkflowOption[];
103: }
104: 
105: export interface PageDefinition {
106:   id: string;
107:   label: string;
108:   detector: ConditionSpec;
109:   workflows: WorkflowDefinition[];
110: }
111: 
112: export interface ThemeConfig {
113:   primary: string;
114:   background: string;
115:   text: string;
116:   accent: string;
117: }
118: 
119: export interface Settings {
120:   theme: ThemeConfig;
121:   interActionDelayMs: number;
122:   loadingIndicator?: SelectorSpec;
123: }
124: 
125: export interface Registry {
126:   pages: PageDefinition[];
127: }
</file>

<file path="packages/core/src/ui.ts">
  1: import type { PageDefinition, Registry, Settings, ThemeConfig, WorkflowDefinition, WorkflowOption } from './types';
  2: import { Store } from './storage';
  3: import { uniqueId } from './utils';
  4: import { highlight, findAll } from './selector';
  5: 
  6: const DEFAULT_THEME: ThemeConfig = {
  7:   primary: '#1f7a8c',
  8:   background: '#0b0c10e6',
  9:   text: '#f5f7fb',
 10:   accent: '#ffbd59'
 11: };
 12: 
 13: export class MenuUI {
 14:   private shadow: ShadowRoot;
 15:   private container: HTMLElement;
 16:   private gear: HTMLButtonElement;
 17:   private open = false;
 18:   private store: Store;
 19:   private settings: Settings;
 20:   private registry: Registry;
 21:   private currentPage?: PageDefinition;
 22:   private currentWorkflow?: WorkflowDefinition;
 23:   private logs: string[] = [];
 24: 
 25:   constructor(registry: Registry, store: Store){
 26:     this.registry = registry;
 27:     this.store = store;
 28:     this.settings = store.get<Settings>('settings', { theme: DEFAULT_THEME, interActionDelayMs: 120 });
 29:     const host = document.createElement('div');
 30:     host.id = 'cv-menu-host';
 31:     document.documentElement.appendChild(host);
 32:     this.shadow = host.attachShadow({ mode: 'open' });
 33:     const style = document.createElement('style');
 34:     style.textContent = this.css();
 35:     this.shadow.appendChild(style);
 36:     this.container = document.createElement('div');
 37:     this.container.className = 'cv-panel';
 38:     this.container.innerHTML = this.panelHtml();
 39:     this.shadow.appendChild(this.container);
 40: 
 41:     this.gear = document.createElement('button');
 42:     this.gear.className = 'cv-gear';
 43:     this.gear.title = 'Carvana Automations';
 44:     this.gear.textContent = '⚙️';
 45:     this.gear.addEventListener('click', () => this.toggle());
 46:     this.shadow.appendChild(this.gear);
 47: 
 48:     this.bind();
 49:     this.applyTheme();
 50:   }
 51: 
 52:   setPage(page?: PageDefinition){
 53:     this.currentPage = page;
 54:     this.renderWorkflows();
 55:     this.appendLog(`Detected page: ${page?.label ?? 'Unknown'}`);
 56:   }
 57: 
 58:   setCurrentWorkflow(wf?: WorkflowDefinition){
 59:     this.currentWorkflow = wf;
 60:     this.renderOptions();
 61:   }
 62: 
 63:   appendLog(line: string){
 64:     this.logs.unshift(`${new Date().toLocaleTimeString()} ${line}`);
 65:     const el = this.shadow.getElementById('cv-logs') as HTMLTextAreaElement | null;
 66:     if (el) el.value = this.logs.join('\n');
 67:   }
 68: 
 69:   toggle(){
 70:     this.open = !this.open;
 71:     this.container.classList.toggle('open', this.open);
 72:     if (this.open) {
 73:       const firstTab = this.shadow.querySelector('[data-tab="cv-tab-workflows"]') as HTMLElement | null;
 74:       firstTab?.click();
 75:     }
 76:   }
 77: 
 78:   private bind(){
 79:     const tabs = this.shadow.querySelectorAll('[data-tab]');
 80:     tabs.forEach(t => {
 81:       t.addEventListener('click', () => {
 82:         this.shadow.querySelectorAll('.cv-tab').forEach(el => el.classList.remove('active'));
 83:         (t as HTMLElement).classList.add('active');
 84:         this.shadow.querySelectorAll('.cv-section').forEach(el => el.classList.remove('active'));
 85:         const target = (t as HTMLElement).getAttribute('data-tab')!;
 86:         (this.shadow.getElementById(target)!).classList.add('active');
 87:       });
 88:     });
 89: 
 90:     this.shadow.getElementById('cv-theme-apply')?.addEventListener('click', () => {
 91:       const primary = (this.shadow.getElementById('cv-theme-primary') as HTMLInputElement).value;
 92:       const bg = (this.shadow.getElementById('cv-theme-bg') as HTMLInputElement).value;
 93:       const text = (this.shadow.getElementById('cv-theme-text') as HTMLInputElement).value;
 94:       const accent = (this.shadow.getElementById('cv-theme-accent') as HTMLInputElement).value;
 95:       this.settings.theme = { primary, background: bg, text, accent };
 96:       this.applyTheme();
 97:       this.store.set('settings', this.settings);
 98:     });
 99: 
100:     this.shadow.getElementById('cv-export')?.addEventListener('click', () => {
101:       const json = JSON.stringify(this.store.exportAll(), null, 2);
102:       navigator.clipboard.writeText(json);
103:       alert('Settings exported to clipboard.');
104:     });
105:     this.shadow.getElementById('cv-import')?.addEventListener('click', async () => {
106:       const text = prompt('Paste the exported JSON here:');
107:       if (!text) return;
108:       try {
109:         const obj = JSON.parse(text);
110:         this.store.importAll(obj);
111:         alert('Imported. Reload the page to take effect.');
112:       } catch (e) {
113:         alert('Invalid JSON');
114:       }
115:     });
116: 
117:     // Selector test button (delegated)
118:     this.shadow.addEventListener('click', (ev) => {
119:       const t = ev.target as HTMLElement;
120:       if (t && t.matches('.cv-test-selectors')){
121:         const ta = this.shadow.getElementById('cv-selector-json') as HTMLTextAreaElement;
122:         try {
123:           const parsed = JSON.parse(ta.value);
124:           const wf = parsed && parsed.steps ? parsed : null;
125:           const spec = wf ? null : parsed; // test either a Workflow or a raw SelectorSpec
126:           const tryMatch = (sp: any) => {
127:             let els = findAll(sp, { visibleOnly: true });
128:             if (els.length === 0) els = findAll(sp, { visibleOnly: false }); // retry hidden (e.g., <title>)
129:             highlight(els);
130:             alert(`Matched ${els.length} element(s).`);
131:           };
132:           if (spec) {
133:             tryMatch(spec);
134:           } else if (wf) {
135:             const first = wf.steps.find((s: any) => s.target);
136:             if (first?.target) tryMatch(first.target);
137:             else alert('No target found in first step to test.');
138:           }
139:         } catch (e: any) {
140:           alert('Invalid JSON: ' + e.message);
141:         }
142:       }
143:     });
144:   }
145: 
146:   private renderWorkflows(){
147:     const list = this.shadow.getElementById('cv-wf-list')!;
148:     list.innerHTML = '';
149:     const page = this.currentPage;
150:     if (!page){
151:       list.innerHTML = '<div class="cv-empty">No page detected yet</div>';
152:       return;
153:     }
154:     for (const wf of page.workflows){
155:       const item = document.createElement('div');
156:       item.className = 'cv-wf-item';
157:       item.innerHTML = `
158:         <div class="cv-wf-title">${wf.label}</div>
159:         <div class="cv-wf-desc">${wf.description || ''}</div>
160:         <div class="cv-wf-actions">
161:           <button class="cv-btn cv-run" data-wf="${wf.id}">Run</button>
162:           <button class="cv-btn cv-edit" data-wf="${wf.id}">Selectors</button>
163:           <button class="cv-btn cv-opt" data-wf="${wf.id}">Options</button>
164:         </div>
165:       `;
166:       item.querySelector('.cv-run')!.addEventListener('click', () => {
167:         this.dispatch('run-workflow', { workflowId: wf.id });
168:       });
169:       item.querySelector('.cv-edit')!.addEventListener('click', () => {
170:         this.showSelectorEditor(wf);
171:       });
172:       item.querySelector('.cv-opt')!.addEventListener('click', () => {
173:         this.setCurrentWorkflow(wf);
174:         const tabBtn = this.shadow.querySelector('[data-tab="cv-tab-options"]') as HTMLElement;
175:         tabBtn.click();
176:         this.renderOptions();
177:       });
178:       list.appendChild(item);
179:     }
180:   }
181: 
182:   private savedOptionsFor(wf: WorkflowDefinition): Record<string, any> {
183:     return this.store.get(`wf:opts:${wf.id}`, {});
184:   }
185: 
186:   private renderOptions(){
187:     const wrap = this.shadow.getElementById('cv-options-wrap')!;
188:     wrap.innerHTML = '';
189:     const wf = this.currentWorkflow;
190:     if (!wf) {
191:       wrap.innerHTML = '<div class="cv-empty">Select a workflow and click Options.</div>';
192:       return;
193:     }
194:     const saved = this.savedOptionsFor(wf);
195:     const form = document.createElement('div');
196:     form.className = 'cv-form';
197:     (wf.options || []).forEach(opt => {
198:       form.appendChild(this.renderOptionField(opt, saved[opt.key]));
199:     });
200:     const row = document.createElement('div');
201:     row.className = 'cv-row right';
202:     const save = document.createElement('button');
203:     save.className = 'cv-btn';
204:     save.textContent = 'Save Options';
205:     save.addEventListener('click', () => {
206:       const values: Record<string, any> = {};
207:       (wf.options || []).forEach(opt => {
208:         const el = this.shadow.getElementById(`cv-opt-${opt.key}`) as HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement | null;
209:         if (!el) return;
210:         if (opt.type === 'boolean') values[opt.key] = (el as HTMLInputElement).checked;
211:         else if (opt.type === 'number') values[opt.key] = parseFloat((el as HTMLInputElement).value);
212:         else if (opt.type === 'multi') {
213:           const lines = (el as HTMLTextAreaElement).value.split('\n').map(s => s.trim()).filter(Boolean);
214:           values[opt.key] = lines;
215:         } else if (opt.type === 'json') {
216:           try { values[opt.key] = JSON.parse((el as HTMLTextAreaElement).value || 'null'); }
217:           catch { alert(`Invalid JSON for ${opt.key}`); return; }
218:         } else {
219:           values[opt.key] = (el as HTMLInputElement | HTMLSelectElement).value;
220:         }
221:       });
222:       this.dispatch('save-options', { workflowId: wf.id, values });
223:     });
224:     row.appendChild(save);
225:     wrap.appendChild(form);
226:     wrap.appendChild(row);
227:   }
228: 
229:   private renderOptionField(opt: WorkflowOption, current: any): HTMLElement {
230:     const field = document.createElement('div');
231:     field.className = 'cv-row';
232:     const id = `cv-opt-${opt.key}`;
233:     const label = document.createElement('label');
234:     label.textContent = opt.label + ' ';
235:     let input: HTMLElement;
236:     const value = current ?? (opt as any).default ?? '';
237: 
238:     switch (opt.type) {
239:       case 'boolean':
240:         input = document.createElement('input');
241:         (input as HTMLInputElement).type = 'checkbox';
242:         (input as HTMLInputElement).checked = !!value;
243:         break;
244:       case 'number':
245:         input = document.createElement('input');
246:         (input as HTMLInputElement).type = 'number';
247:         (input as HTMLInputElement).value = String(value ?? '');
248:         break;
249:       case 'select':
250:         input = document.createElement('select');
251:         (opt.choices || []).forEach(c => {
252:           const o = document.createElement('option');
253:           o.value = c.value; o.textContent = c.label;
254:           if (c.value === value) o.selected = true;
255:           (input as HTMLSelectElement).appendChild(o);
256:         });
257:         break;
258:       case 'multi':
259:         input = document.createElement('textarea');
260:         (input as HTMLTextAreaElement).value = Array.isArray(value) ? value.join('\n') : '';
261:         (input as HTMLTextAreaElement).placeholder = (opt as any).hint ?? 'one item per line';
262:         (input as HTMLTextAreaElement).className = 'cv-textarea';
263:         break;
264:       case 'json':
265:         input = document.createElement('textarea');
266:         (input as HTMLTextAreaElement).value = JSON.stringify(value ?? null, null, 2);
267:         (input as HTMLTextAreaElement).className = 'cv-textarea';
268:         break;
269:       default: // string
270:         input = document.createElement('input');
271:         (input as HTMLInputElement).type = 'text';
272:         (input as HTMLInputElement).value = String(value ?? '');
273:     }
274: 
275:     input.id = id;
276:     label.htmlFor = id;
277:     field.appendChild(label);
278:     field.appendChild(input);
279:     return field;
280:   }
281: 
282:   private showSelectorEditor(wf: WorkflowDefinition){
283:     this.setCurrentWorkflow(wf);
284:     const tabBtn = this.shadow.querySelector('[data-tab="cv-tab-selectors"]') as HTMLElement;
285:     tabBtn.click();
286:     const ta = this.shadow.getElementById('cv-selector-json') as HTMLTextAreaElement;
287:     ta.value = JSON.stringify(wf, null, 2);
288:     (this.shadow.getElementById('cv-selector-save') as HTMLButtonElement).onclick = () => {
289:       try{
290:         const parsed = JSON.parse(ta.value) as WorkflowDefinition;
291:         if (this.currentPage){
292:           const idx = this.currentPage.workflows.findIndex(x => x.id === wf.id);
293:           if (idx >= 0) this.currentPage.workflows[idx] = parsed;
294:         }
295:         alert('Saved in-memory. Use Export to persist or run to test.');
296:       } catch (e: any){
297:         alert('Invalid JSON: ' + e.message);
298:       }
299:     };
300:   }
301: 
302:   private panelHtml(){
303:     return `
304:     <div class="cv-header">
305:       <div class="cv-title">Carvana Automations</div>
306:       <div class="cv-tabs">
307:         <button class="cv-tab active" data-tab="cv-tab-workflows">Workflows</button>
308:         <button class="cv-tab" data-tab="cv-tab-selectors">Selectors</button>
309:         <button class="cv-tab" data-tab="cv-tab-options">Options</button>
310:         <button class="cv-tab" data-tab="cv-tab-theme">Theme</button>
311:         <button class="cv-tab" data-tab="cv-tab-storage">Storage</button>
312:         <button class="cv-tab" data-tab="cv-tab-logs">Logs</button>
313:       </div>
314:     </div>
315:     <div id="cv-tab-workflows" class="cv-section active">
316:       <div id="cv-wf-list"></div>
317:     </div>
318:     <div id="cv-tab-selectors" class="cv-section">
319:       <div class="cv-row">
320:         <textarea id="cv-selector-json" class="cv-textarea" spellcheck="false" placeholder="Workflow JSON (editable)"></textarea>
321:       </div>
322:       <div class="cv-row right">
323:         <button class="cv-btn cv-test-selectors">Test Match</button>
324:         <button id="cv-selector-save" class="cv-btn">Save (in-memory)</button>
325:       </div>
326:     </div>
327:     <div id="cv-tab-options" class="cv-section">
328:       <div id="cv-options-wrap"></div>
329:     </div>
330:     <div id="cv-tab-theme" class="cv-section">
331:       <div class="cv-row">
332:         <label>Primary <input type="color" id="cv-theme-primary" value="#1f7a8c"></label>
333:         <label>Background <input type="color" id="cv-theme-bg" value="#0b0c10"></label>
334:         <label>Text <input type="color" id="cv-theme-text" value="#f5f7fb"></label>
335:         <label>Accent <input type="color" id="cv-theme-accent" value="#ffbd59"></label>
336:         <button id="cv-theme-apply" class="cv-btn">Apply</button>
337:       </div>
338:     </div>
339:     <div id="cv-tab-storage" class="cv-section">
340:       <div class="cv-row">
341:         <button id="cv-export" class="cv-btn">Export Config to Clipboard</button>
342:         <button id="cv-import" class="cv-btn">Import Config</button>
343:       </div>
344:     </div>
345:     <div id="cv-tab-logs" class="cv-section">
346:       <textarea id="cv-logs" class="cv-textarea" readonly></textarea>
347:     </div>
348:     `;
349:   }
350: 
351:   private css(){
352:     return `
353:       :host { all: initial; }
354:       .cv-gear{
355:         position: fixed; bottom: 16px; right: 16px; z-index: 999999999;
356:         border-radius: 50%; width: 44px; height: 44px; border: none; cursor: pointer;
357:         background: var(--cv-primary); color: var(--cv-text); box-shadow: 0 2px 10px rgba(0,0,0,.4);
358:       }
359:       .cv-panel{
360:         position: fixed; bottom: 72px; right: 16px; width: 480px; max-height: 70vh; overflow: hidden;
361:         background: var(--cv-bg); color: var(--cv-text); border: 1px solid rgba(255,255,255,.08);
362:         border-radius: 10px; box-shadow: 0 8px 30px rgba(0,0,0,.45);
363:         transform: translateY(12px); opacity: 0; pointer-events: none; transition: all .18s ease;
364:         font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, 'Helvetica Neue', Arial, 'Apple Color Emoji','Segoe UI Emoji';
365:       }
366:       .cv-panel.open{ transform: translateY(0); opacity: 1; pointer-events: all; }
367:       .cv-header{ display: flex; align-items: center; justify-content: space-between; padding: 10px 12px; background: linear-gradient(0deg, rgba(255,255,255,.02), transparent); }
368:       .cv-title{ font-weight: 600; letter-spacing: .3px; }
369:       .cv-tabs{ display:flex; gap:6px; }
370:       .cv-tab{ background: transparent; color: var(--cv-text); border: 1px solid rgba(255,255,255,.18); padding: 6px 10px; border-radius: 6px; cursor: pointer; }
371:       .cv-tab.active{ background: rgba(255,255,255,.08); }
372:       .cv-section{ display: none; padding: 10px; }
373:       .cv-section.active{ display:block; max-height: calc(70vh - 58px); overflow-y: auto; }
374:       .cv-row{ display:flex; gap:10px; align-items:center; margin: 8px 0; }
375:       .cv-row.right{ justify-content:flex-end; }
376:       .cv-textarea{ width: 100%; min-height: 240px; background: rgba(0,0,0,.3); color: var(--cv-text); border: 1px solid rgba(255,255,255,.15); border-radius: 8px; padding: 8px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace; font-size: 12px; }
377:       .cv-btn{ background: var(--cv-primary); color: var(--cv-text); border: none; padding: 6px 10px; border-radius: 6px; cursor: pointer; }
378:       .cv-empty{ opacity: .7; padding: 8px; }
379:       .cv-wf-item{ border: 1px solid rgba(255,255,255,.12); border-radius: 8px; padding: 8px; margin-bottom: 8px; }
380:       .cv-wf-title{ font-weight: 600; margin-bottom: 4px; }
381:       .cv-wf-actions{ display:flex; gap:8px; }
382:       .cv-form label { width: 160px; display: inline-block; }
383:     `;
384:   }
385: 
386:   private dispatch(type: string, detail: any){
387:     window.dispatchEvent(new CustomEvent(`cv-menu:${type}`, { detail }));
388:   }
389: }
</file>

<file path="packages/core/src/utils.ts">
 1: export const sleep = (ms: number) => new Promise(res => setTimeout(res, ms));
 2: 
 3: export function now(){ return performance.now ? performance.now() : Date.now(); }
 4: 
 5: export function toRegExp(m: {regex: string, flags?: string}){
 6:   try { return new RegExp(m.regex, m.flags); } catch { return null; }
 7: }
 8: 
 9: export function normalizeWhitespace(s: string){
10:   return s.replace(/\s+/g, ' ').trim();
11: }
12: 
13: export function isVisible(el: Element){
14:   const style = getComputedStyle(el as HTMLElement);
15:   const rect = (el as HTMLElement).getBoundingClientRect();
16:   return style && style.visibility !== 'hidden' && style.display !== 'none' && rect.width > 0 && rect.height > 0;
17: }
18: 
19: export function asArray<T>(v: T | T[] | null | undefined): T[] {
20:   if (v == null) return [];
21:   return Array.isArray(v) ? v : [v];
22: }
23: 
24: export function uniqueId(prefix='id'){
25:   return `${prefix}-${Math.random().toString(36).slice(2,10)}`;
26: }
</file>

<file path="packages/core/src/wait.ts">
 1: import type { SelectorSpec, WaitOptions } from './types';
 2: import { findOne } from './selector';
 3: import { sleep, now } from './utils';
 4: 
 5: export async function waitForElement(spec: SelectorSpec, opts?: WaitOptions): Promise<Element>{
 6:   const timeoutMs = opts?.timeoutMs ?? 15000;
 7:   const poll = opts?.pollIntervalMs ?? 200;
 8:   const visibleOnly = !!opts?.visibleOnly;
 9:   const stableMs = opts?.minStabilityMs ?? 0;
10:   const start = now();
11: 
12:   const existing = findOne(spec, { visibleOnly });
13:   if (existing) return existing;
14: 
15:   return new Promise<Element>((resolve, reject) => {
16:     let timer: number|undefined;
17:     let stableTimer: number|undefined;
18:     const observer = new MutationObserver(() => {
19:       const el = findOne(spec, { visibleOnly });
20:       if (!el) return;
21:       if (stableMs <= 0) {
22:         cleanup(); resolve(el); return;
23:       }
24:       if (stableTimer) clearTimeout(stableTimer);
25:       stableTimer = window.setTimeout(() => { cleanup(); resolve(el); }, stableMs);
26:     });
27: 
28:     const cleanup = () => {
29:       observer.disconnect();
30:       if (timer) window.clearTimeout(timer);
31:       if (stableTimer) window.clearTimeout(stableTimer);
32:     };
33: 
34:     observer.observe(document.documentElement, { childList: true, subtree: true, attributes: true });
35:     // Timeout fallback
36:     timer = window.setTimeout(() => {
37:       cleanup();
38:       reject(new Error(`Timeout after ${timeoutMs}ms waiting for element`));
39:     }, timeoutMs);
40: 
41:     // Poll fallback (covers attribute-only changes that MO might miss for performance reasons)
42:     (async () => {
43:       while (now() - start < timeoutMs){
44:         const el = findOne(spec, { visibleOnly });
45:         if (el) { cleanup(); resolve(el); return; }
46:         await sleep(poll);
47:       }
48:     })();
49:   });
50: }
51: 
52: export function onDocumentReady(): Promise<void>{
53:   if (document.readyState === 'complete' || document.readyState === 'interactive') return Promise.resolve();
54:   return new Promise(res => {
55:     document.addEventListener('DOMContentLoaded', () => res(), { once: true });
56:   });
57: }
</file>

<file path="packages/core/src/workflow.ts">
  1: import type {
  2:   Action, ActionResult, ConditionSpec, PageDefinition, Registry,
  3:   SelectorSpec, Settings, WorkflowDefinition, GlobalSource, SourceSpec
  4: } from './types';
  5: import { findOne, findAll } from './selector';
  6: import { Store } from './storage';
  7: import { copy } from './clipboard';
  8: import { onDocumentReady, waitForElement } from './wait';
  9: import { sleep } from './utils';
 10: import { MenuUI } from './ui';
 11: import { deepRenderTemplates } from './templating';
 12: import { extractListData, takeFromElement } from './data';
 13: 
 14: function isGlobalSource(s: SourceSpec): s is GlobalSource {
 15:   return (s as any)?.global != null;
 16: }
 17: 
 18: function readGlobal(g: GlobalSource): string {
 19:   switch (g.global) {
 20:     case 'document.title': return document.title || '';
 21:     case 'location.href': return location.href;
 22:     case 'location.host': return location.host;
 23:     case 'location.pathname': return location.pathname;
 24:     case 'navigator.userAgent': return navigator.userAgent;
 25:     case 'timestamp': return new Date().toISOString();
 26:     default: return '';
 27:   }
 28: }
 29: 
 30: export class Engine {
 31:   private store: Store;
 32:   private registry: Registry;
 33:   private settings: Settings;
 34:   private ui: MenuUI;
 35:   private currentPage?: PageDefinition;
 36:   private running = false;
 37: 
 38:   constructor(registry: Registry, store: Store){
 39:     this.store = store;
 40:     this.registry = registry;
 41:     this.settings = store.get<Settings>('settings', {
 42:       theme: { primary:'#1f7a8c', background:'#0b0c10e6', text:'#f5f7fb', accent:'#ffbd59' },
 43:       interActionDelayMs: 120
 44:     });
 45:     this.ui = new MenuUI(registry, store);
 46: 
 47:     window.addEventListener('cv-menu:run-workflow' as any, (ev: any) => {
 48:       const id = ev.detail.workflowId as string;
 49:       if (!this.currentPage) return;
 50:       const wf = this.currentPage.workflows.find(w => w.id === id);
 51:       if (wf) this.runWorkflow(wf).catch(err => console.error(err));
 52:     });
 53: 
 54:     window.addEventListener('cv-menu:save-options' as any, (ev: any) => {
 55:       const { workflowId, values } = ev.detail || {};
 56:       if (!workflowId) return;
 57:       this.store.set(`wf:opts:${workflowId}`, values || {});
 58:       alert(`Saved options for ${workflowId}`);
 59:     });
 60:   }
 61: 
 62:   async boot(){
 63:     await onDocumentReady();
 64:     const page = await this.detectPage();
 65:     this.currentPage = page;
 66:     this.ui.setPage(page);
 67: 
 68:     if (typeof GM_registerMenuCommand !== 'undefined') {
 69:       GM_registerMenuCommand('CV: Toggle Menu', () => (this.ui as any)['toggle']?.());
 70:       GM_registerMenuCommand('CV: Detect Page', async () => {
 71:         const p = await this.detectPage();
 72:         this.currentPage = p;
 73:         this.ui.setPage(p);
 74:       });
 75:     }
 76:   }
 77: 
 78:   private async detectPage(): Promise<PageDefinition|undefined>{
 79:     for (const p of this.registry.pages){
 80:       const ok = await this.evalCondition(p.detector);
 81:       if (ok) return p;
 82:     }
 83:     return undefined;
 84:   }
 85: 
 86:   private async evalCondition(c?: ConditionSpec): Promise<boolean>{
 87:     if (!c) return true;
 88:     if ('exists' in c) return !!findOne(c.exists, { visibleOnly: true });
 89:     if ('notExists' in c) return !findOne(c.notExists, { visibleOnly: true });
 90:     if ('textPresent' in c) {
 91:       const el = findOne(c.textPresent.where, { visibleOnly: true });
 92:       if (!el) return false;
 93:       const txt = (el.textContent || '').trim();
 94:       const m = c.textPresent.matcher;
 95:       if ('equals' in m) return (m.caseInsensitive ? txt.toLowerCase() === m.equals.toLowerCase() : txt === m.equals);
 96:       if ('includes' in m) return (m.caseInsensitive ? txt.toLowerCase().includes(m.includes.toLowerCase()) : txt.includes(m.includes));
 97:       if ('regex' in m) { try { return new RegExp(m.regex, m.flags).test(txt); } catch { return false; } }
 98:       return false;
 99:     }
100:     if ('any' in c) { for (const sub of c.any) if (await this.evalCondition(sub)) return true; return false; }
101:     if ('all' in c) { for (const sub of c.all) if (!(await this.evalCondition(sub))) return false; return true; }
102:     if ('not' in c) return !(await this.evalCondition(c.not));
103:     return false;
104:   }
105: 
106:   private getWorkflowOptions(wf: WorkflowDefinition): Record<string, any> {
107:     const saved = this.store.get<Record<string, any>>(`wf:opts:${wf.id}`, {});
108:     const defaults: Record<string, any> = {};
109:     for (const opt of (wf.options || [])){
110:       defaults[opt.key] = (opt as any).default;
111:     }
112:     return { ...defaults, ...saved };
113:   }
114: 
115:   async runWorkflow(wf: WorkflowDefinition, nested = false){
116:     if (!wf) return;
117:     if (this.running && !nested) { alert('A workflow is already running.'); return; }
118:     const wasRunning = this.running;
119:     if (!nested) this.running = true;
120: 
121:     this.store.set('lastWorkflow', { id: wf.id, at: Date.now() });
122: 
123:     const ctx = { opt: this.getWorkflowOptions(wf) };
124: 
125:     try {
126:       for (let i=0; i<wf.steps.length; i++){
127:         const rawStep = wf.steps[i];
128:         const step = deepRenderTemplates(rawStep, ctx) as Action;   // inject {{opt.*}}
129:         this.store.set('lastStep', { workflowId: wf.id, index: i });
130:         const res = await this.execStep(step);
131:         if (!res.ok) throw new Error(res.error);
132:         await this.afterActionWaits();
133:         await sleep(this.settings.interActionDelayMs);
134:       }
135:       if (!nested) alert(`Workflow "${wf.label}" completed.`);
136:     } catch (e: any) {
137:       console.error(e);
138:       if (!nested) alert(`Workflow "${wf.label}" failed: ${e.message}`);
139:     } finally {
140:       if (!nested) this.running = wasRunning;
141:     }
142:   }
143: 
144:   private async afterActionWaits(){
145:     const ind = this.settings.loadingIndicator;
146:     if (!ind) return;
147:     try {
148:       const start = Date.now();
149:       const timeout = 60000;
150:       while (Date.now() - start < timeout){
151:         const visible = !!findOne(ind, { visibleOnly: true });
152:         if (!visible) break;
153:         await sleep(150);
154:       }
155:     } catch { /* ignore */ }
156:   }
157: 
158:   private async execStep(step: Action): Promise<ActionResult>{
159:     switch (step.kind){
160:       case 'waitFor': {
161:         await waitForElement(step.target, step.wait);
162:         return { ok: true };
163:       }
164:       case 'delay': {
165:         await sleep(step.ms);
166:         return { ok: true };
167:       }
168:       case 'click': {
169:         if (step.preWait) await waitForElement(step.target, step.preWait);
170:         const el = findOne(step.target, { visibleOnly: true });
171:         if (!el) return { ok: false, error: 'click: target not found' };
172:         (el as HTMLElement).click();
173:         if (step.postWaitFor) await waitForElement(step.postWaitFor, { timeoutMs: 15000, visibleOnly: true });
174:         return { ok: true };
175:       }
176:       case 'type': {
177:         const el = findOne(step.target, { visibleOnly: true }) as HTMLInputElement | HTMLTextAreaElement | null;
178:         if (!el) return { ok: false, error: 'type: target not found' };
179:         el.focus();
180:         if (step.clearFirst) {
181:           (el as any).value = '';
182:           el.dispatchEvent(new InputEvent('input', { bubbles: true }));
183:         }
184:         for (const ch of step.text.split('')){
185:           (el as any).value = ((el as any).value || '') + ch;
186:           el.dispatchEvent(new InputEvent('input', { bubbles: true }));
187:           await sleep(step.perKeystrokeDelayMs ?? 15);
188:         }
189:         el.dispatchEvent(new Event('change', { bubbles: true }));
190:         if (step.postEnter){
191:           (el as any).dispatchEvent(new KeyboardEvent('keydown', { key: 'Enter', bubbles: true }));
192:           (el as any).dispatchEvent(new KeyboardEvent('keyup', { key: 'Enter', bubbles: true }));
193:         }
194:         return { ok: true };
195:       }
196:       case 'selectFromList': {
197:         const list = await waitForElement(step.list, { timeoutMs: 10000, visibleOnly: true });
198:         const items = findAll(step.item, { root: list, visibleOnly: true });
199:         if (items.length === 0) return { ok: false, error: 'selectFromList: item not found' };
200:         (items[0] as HTMLElement).click();
201:         return { ok: true };
202:       }
203:       case 'extract': {
204:         const out: Record<string, any> = {};
205:         for (const it of step.items){
206:           if (isGlobalSource(it.from)) {
207:             out[it.intoKey] = readGlobal(it.from);
208:             continue;
209:           }
210:           const el = findOne(it.from as SelectorSpec, { visibleOnly: false });
211:           if (!el) { out[it.intoKey] = ''; continue; }
212:           out[it.intoKey] = takeFromElement(el, it.take);
213:         }
214:         if ((step as any).copyToClipboard) copy(JSON.stringify(out, null, 2));
215:         if ((step as any).present) this.present(out);
216:         return { ok: true, data: out };
217:       }
218:       case 'extractList': {
219:         const limit = Number(step.limit) || 20;
220:         const arr = extractListData(step.list, step.fields, limit, { visibleOnly: step.visibleOnly ?? true });
221:         const out: Record<string, any> = { [step.intoKey]: arr };
222:         if ((step as any).copyToClipboard) copy(JSON.stringify(out, null, 2));
223:         if ((step as any).present) this.present(out);
224:         return { ok: true, data: out };
225:       }
226:       case 'branch': {
227:         const ok = await this.evalCondition(step.condition);
228:         if (ok && step.thenWorkflow){
229:           const wf = this.findWorkflow(step.thenWorkflow);
230:           if (wf) await this.runWorkflow(wf, true);  // nested
231:           return { ok: true };
232:         }
233:         if (!ok && step.elseWorkflow){
234:           const wf = this.findWorkflow(step.elseWorkflow);
235:           if (wf) await this.runWorkflow(wf, true);  // nested
236:           return { ok: true };
237:         }
238:         return { ok: true };
239:       }
240:       case 'error': {
241:         alert(step.message);
242:         return { ok: true };
243:       }
244:       default:
245:         return { ok: false, error: `Unsupported step kind: ${(step as any).kind}` };
246:     }
247:   }
248: 
249:   private findWorkflow(id: string): WorkflowDefinition | undefined {
250:     for (const p of this.registry.pages){
251:       for (const w of p.workflows){
252:         if (w.id === id) return w;
253:       }
254:     }
255:     return undefined;
256:   }
257: 
258:   private present(obj: Record<string, any>){
259:     const pre = document.createElement('pre');
260:     pre.textContent = JSON.stringify(obj, null, 2);
261:     Object.assign(pre.style, {
262:       position: 'fixed', right: '16px', top: '16px', background: 'rgba(0,0,0,.85)', color: '#fff',
263:       padding: '10px', zIndex: '99999999', maxHeight: '60vh', overflow: 'auto', borderRadius: '8px'
264:     } as any);
265:     document.body.appendChild(pre);
266:     setTimeout(() => pre.remove(), 4000);
267:   }
268: }
</file>

<file path="packages/core/test/extractList.test.ts">
 1: import { describe, it, expect } from 'vitest';
 2: import { extractListData } from '@cv/core';
 3: 
 4: describe('extractListData', () => {
 5:   it('extracts top N anchors text+href', () => {
 6:     document.body.innerHTML = `
 7:       <a href="https://a.example/x">First</a>
 8:       <a href="/rel">Second</a>
 9:       <a>Third (no href)</a>
10:     `;
11:     const rows = extractListData(
12:       { selector: 'a' },
13:       [{ key: 'text', take: 'text' }, { key: 'href', take: 'href' }],
14:       10,
15:       { visibleOnly: false }
16:     );
17:     expect(rows.length).toBe(3);
18:     expect(rows[0].text).toBe('First');
19:     expect(rows[0].href).toMatch('https://a.example/x');
20:     expect(rows[2].href).toBe(''); // no href
21:   });
22: });
</file>

<file path="packages/core/test/selector.test.ts">
 1: import { describe, it, expect } from 'vitest';
 2: import { findAll } from '@cv/core';
 3: 
 4: describe('selector', () => {
 5:   it('matches text.includes', () => {
 6:     document.body.innerHTML = `<button>Resolve</button>`;
 7:     const els = findAll({ tag: 'button', text: { includes: 'resol', caseInsensitive: true } }, { visibleOnly: true });
 8:     expect(els.length).toBe(1);
 9:   });
10: });
</file>

<file path="packages/core/test/templating.test.ts">
 1: import { describe, it, expect } from 'vitest';
 2: import { renderTemplate, deepRenderTemplates } from '@cv/core';
 3: 
 4: describe('templating', () => {
 5:   it('replaces simple placeholders', () => {
 6:     const s = renderTemplate('Hello {{ opt.name }}!', { opt: { name: 'World' } });
 7:     expect(s).toBe('Hello World!');
 8:   });
 9: 
10:   it('deeply renders objects', () => {
11:     const step = { kind: 'type', text: 'Val: {{ opt.value }}' } as any;
12:     const out = deepRenderTemplates(step, { opt: { value: 42 } });
13:     expect(out.text).toBe('Val: 42');
14:   });
15: });
</file>

<file path="packages/jira-userscript/metadata.json">
 1: {
 2:   "name": "CV Automations — Jira",
 3:   "namespace": "cv-userscripts",
 4:   "version": "0.1.0",
 5:   "description": "Carvana automation foundation for Jira.",
 6:   "author": "Carvana Automation",
 7:   "match": [
 8:     "https://jira.carvana.com/*"
 9:   ],
10:   "run-at": "document-end",
11:   "grant": [
12:     "GM_getValue",
13:     "GM_setValue",
14:     "GM_listValues",
15:     "GM_deleteValue",
16:     "GM_setClipboard",
17:     "GM_registerMenuCommand",
18:     "GM_unregisterMenuCommand",
19:     "GM_addStyle",
20:     "unsafeWindow"
21:   ]
22: }
</file>

<file path="packages/jira-userscript/package.json">
1: {
2:   "name": "@cv/jira-userscript",
3:   "version": "0.1.0",
4:   "private": true,
5:   "type": "module"
6: }
</file>

<file path="packages/jira-userscript/src/index.ts">
1: import { Engine, Store, Registry } from '@cv/core';
2: import { JiraFallbackPage } from './pages/fallback-demo';
3: 
4: (async () => {
5:   const store = new Store('cv:jira');
6:   const registry: Registry = { pages: [JiraFallbackPage] }; // demos only
7:   const engine = new Engine(registry, store);
8:   await engine.boot();
9: })();
</file>

<file path="packages/jira-userscript/src/pages/fallback-demo.ts">
 1: import type { PageDefinition, WorkflowDefinition } from '@cv/core';
 2: 
 3: export const JiraFallbackPage: PageDefinition = {
 4:   id: 'jira.demo',
 5:   label: 'Demo (Jira Site)',
 6:   detector: { exists: { selector: 'body' } },
 7:   workflows: []
 8: };
 9: 
10: // Demo 1: Title -> Clipboard (pure global read)
11: const DemoTitleWorkflow: WorkflowDefinition = {
12:   id: 'demo.title.clipboard',
13:   label: 'Demo: Title → Clipboard',
14:   description: 'Copies document.title and shows it.',
15:   steps: [
16:     { kind: 'extract',
17:       items: [{ from: { global: 'document.title' }, intoKey: 'title', take: 'raw' }],
18:       copyToClipboard: true,
19:       present: true
20:     }
21:   ]
22: };
23: 
24: // Demo 2: Page Info (safe globals)
25: const DemoPageInfoWorkflow: WorkflowDefinition = {
26:   id: 'demo.page.info',
27:   label: 'Demo: Page Info',
28:   description: 'Collects title, URL, host, path, UA, timestamp.',
29:   steps: [
30:     { kind: 'extract',
31:       items: [
32:         { from: { global: 'document.title' }, intoKey: 'title', take: 'raw' },
33:         { from: { global: 'location.href' }, intoKey: 'href', take: 'raw' },
34:         { from: { global: 'location.host' }, intoKey: 'host', take: 'raw' },
35:         { from: { global: 'location.pathname' }, intoKey: 'path', take: 'raw' },
36:         { from: { global: 'navigator.userAgent' }, intoKey: 'ua', take: 'raw' },
37:         { from: { global: 'timestamp' }, intoKey: 'timestamp', take: 'raw' }
38:       ],
39:       present: true,
40:       copyToClipboard: true
41:     }
42:   ]
43: };
44: 
45: // Demo 3: List Links (top N) with options
46: const DemoLinksWorkflow: WorkflowDefinition = {
47:   id: 'demo.links.topN',
48:   label: 'Demo: List Links (top N)',
49:   description: 'Extracts link text & href for the first N anchors.',
50:   options: [
51:     { key: 'maxLinks', label: 'Max links', type: 'number', default: 20 }
52:   ],
53:   steps: [
54:     {
55:       kind: 'extractList',
56:       list: { selector: 'a[href]' },
57:       fields: [
58:         { key: 'text', take: 'text' },
59:         { key: 'href', take: 'href' }
60:       ],
61:       limit: '{{opt.maxLinks}}',
62:       intoKey: 'links',
63:       present: true,
64:       copyToClipboard: true
65:     }
66:   ]
67: };
68: 
69: JiraFallbackPage.workflows.push(DemoTitleWorkflow, DemoPageInfoWorkflow, DemoLinksWorkflow);
</file>

<file path="packages/oracle-userscript/metadata.json">
 1: {
 2:   "name": "CV Automations — Oracle (Carvana)",
 3:   "namespace": "cv-userscripts",
 4:   "version": "0.1.0",
 5:   "description": "Carvana automation foundation for Oracle pages (edsk.fa.us2.oraclecloud.com).",
 6:   "author": "Carvana Automation",
 7:   "match": [
 8:     "https://edsk.fa.us2.oraclecloud.com/*"
 9:   ],
10:   "run-at": "document-end",
11:   "grant": [
12:     "GM_getValue",
13:     "GM_setValue",
14:     "GM_listValues",
15:     "GM_deleteValue",
16:     "GM_setClipboard",
17:     "GM_registerMenuCommand",
18:     "GM_unregisterMenuCommand",
19:     "GM_addStyle",
20:     "unsafeWindow"
21:   ]
22: }
</file>

<file path="packages/oracle-userscript/package.json">
1: {
2:   "name": "@cv/oracle-userscript",
3:   "version": "0.1.0",
4:   "private": true,
5:   "type": "module"
6: }
</file>

<file path="packages/oracle-userscript/src/index.ts">
1: import { Engine, Store, Registry } from '@cv/core';
2: import { OracleFallbackPage } from './pages/fallback-demo';
3: 
4: (async () => {
5:   const store = new Store('cv:oracle');
6:   const registry: Registry = { pages: [OracleFallbackPage] }; // demos only
7:   const engine = new Engine(registry, store);
8:   await engine.boot();
9: })();
</file>

<file path="packages/oracle-userscript/src/pages/fallback-demo.ts">
 1: import type { PageDefinition, WorkflowDefinition } from '@cv/core';
 2: 
 3: export const OracleFallbackPage: PageDefinition = {
 4:   id: 'oracle.demo',
 5:   label: 'Demo (Oracle Site)',
 6:   detector: { exists: { selector: 'body' } },
 7:   workflows: []
 8: };
 9: 
10: const DemoTitleWorkflow: WorkflowDefinition = {
11:   id: 'demo.title.clipboard',
12:   label: 'Demo: Title → Clipboard',
13:   description: 'Copies document.title and shows it.',
14:   steps: [
15:     { kind: 'extract',
16:       items: [{ from: { global: 'document.title' }, intoKey: 'title', take: 'raw' }],
17:       copyToClipboard: true,
18:       present: true
19:     }
20:   ]
21: };
22: 
23: const DemoPageInfoWorkflow: WorkflowDefinition = {
24:   id: 'demo.page.info',
25:   label: 'Demo: Page Info',
26:   description: 'Collects title, URL, host, path, UA, timestamp.',
27:   steps: [
28:     { kind: 'extract',
29:       items: [
30:         { from: { global: 'document.title' }, intoKey: 'title', take: 'raw' },
31:         { from: { global: 'location.href' }, intoKey: 'href', take: 'raw' },
32:         { from: { global: 'location.host' }, intoKey: 'host', take: 'raw' },
33:         { from: { global: 'location.pathname' }, intoKey: 'path', take: 'raw' },
34:         { from: { global: 'navigator.userAgent' }, intoKey: 'ua', take: 'raw' },
35:         { from: { global: 'timestamp' }, intoKey: 'timestamp', take: 'raw' }
36:       ],
37:       present: true,
38:       copyToClipboard: true
39:     }
40:   ]
41: };
42: 
43: const DemoLinksWorkflow: WorkflowDefinition = {
44:   id: 'demo.links.topN',
45:   label: 'Demo: List Links (top N)',
46:   description: 'Extracts link text & href for the first N anchors.',
47:   options: [
48:     { key: 'maxLinks', label: 'Max links', type: 'number', default: 20 }
49:   ],
50:   steps: [
51:     {
52:       kind: 'extractList',
53:       list: { selector: 'a[href]' },
54:       fields: [
55:         { key: 'text', take: 'text' },
56:         { key: 'href', take: 'href' }
57:       ],
58:       limit: '{{opt.maxLinks}}',
59:       intoKey: 'links',
60:       present: true,
61:       copyToClipboard: true
62:     }
63:   ]
64: };
65: 
66: OracleFallbackPage.workflows.push(DemoTitleWorkflow, DemoPageInfoWorkflow, DemoLinksWorkflow);
</file>

<file path="README.md">
 1: # Carvana Automation Userscripts — Foundation
 2: 
 3: Production-ready skeleton for DRY, SOLID, KISS, YAGNI Tampermonkey automation targeting:
 4: 
 5: - **Jira** — `https://jira.carvana.com/*`
 6: - **Oracle (Carvana)** — `https://edsk.fa.us2.oraclecloud.com/*`
 7: 
 8: Shared TypeScript core:
 9: - Non‑brittle selectors (`css/id/role/tag/type/attributes/text`, `and/or/not/within/nth`, `visible`)
10: - Wait utilities with MutationObserver + polling + stability time
11: - Declarative workflows (click/type/wait/extract/branch/error) with persistence/resume
12: - Dynamic menu (Shadow DOM): **Workflows**, **Selectors** (JSON editor + Test), **Theme**, **Storage**, **Logs**
13: 
14: > Looking to build your own pages/workflows? See **[AGENTS.md](./AGENTS.md)**.
15: 
16: ---
17: 
18: ## Quick Start
19: 
20: Requirements: Node 18+, npm.
21: 
22: ```bash
23: npm i
24: npm run build
25: ```
26: 
27: This outputs two files in `dist/`:
28: 
29: * `jira.user.js`
30: * `oracle.user.js`
31: 
32: Install each in Tampermonkey (drag into the browser or paste into a new script).
33: 
34: ---
35: 
36: ## First Run / Demo Workflows
37: 
38: The default registry is **demo‑only**. On a matching site, click the **gear**:
39: 
40: * Run **Demo: Title → Clipboard** to copy the page title and show a preview.
41: * Try **Demo: Page Info** and **Demo: List Links** to validate extraction & presentation.
42: 
43: Then jump to **AGENTS.md** to add your own pages and real workflows.
</file>

<file path="scripts/build.mjs">
 1: import { build } from 'esbuild';
 2: import fs from 'node:fs';
 3: import path from 'node:path';
 4: 
 5: const root = process.cwd();
 6: 
 7: /** @param {Record<string, any>} meta */
 8: function toMetaBlock(meta){
 9:   const lines = ['// ==UserScript=='];
10:   const push = (k, v) => {
11:     if (Array.isArray(v)) v.forEach(val => lines.push(`// @${k.padEnd(15)} ${val}`));
12:     else if (v !== undefined && v !== null) lines.push(`// @${k.padEnd(15)} ${v}`);
13:   };
14: 
15:   for (const [k, v] of Object.entries(meta)) push(k, v);
16:   lines.push('// ==/UserScript==');
17:   return lines.join('\n');
18: }
19: 
20: function loadMeta(pkgDir){
21:   const metaPath = path.join(pkgDir, 'metadata.json');
22:   const meta = JSON.parse(fs.readFileSync(metaPath, 'utf-8'));
23:   // keep version in sync with root version if missing
24:   const rootPkg = JSON.parse(fs.readFileSync(path.join(root, 'package.json'), 'utf-8'));
25:   if (!meta.version) meta.version = rootPkg.version;
26:   return meta;
27: }
28: 
29: async function buildOne(pkgName){
30:   const pkgDir = path.join(root, 'packages', pkgName);
31:   const outDir = path.join(root, 'dist');
32:   const entry = path.join(pkgDir, 'src', 'index.ts');
33:   const meta = loadMeta(pkgDir);
34:   const banner = toMetaBlock(meta) + '\n';
35: 
36:   await build({
37:     entryPoints: [entry],
38:     outfile: path.join(outDir, `${pkgName.replace('-userscript','')}.user.js`),
39:     bundle: true,
40:     platform: 'browser',
41:     format: 'iife',
42:     target: 'es2021',
43:     banner: { js: banner },
44:     sourcemap: true,
45:     legalComments: 'none',
46:     define: {
47:       __US_NAME__: JSON.stringify(meta.name || pkgName),
48:       __US_NAMESPACE__: JSON.stringify(meta.namespace || 'cv-userscripts'),
49:       __US_VERSION__: JSON.stringify(meta.version || '0.1.0')
50:     }
51:   });
52:   console.log(`Built ${pkgName}`);
53: }
54: 
55: const pkgs = ['jira-userscript', 'oracle-userscript'];
56: 
57: fs.mkdirSync(path.join(root, 'dist'), { recursive: true });
58: for (const p of pkgs) await buildOne(p);
59: 
60: console.log('\nAll done. Find userscripts in ./dist/*.user.js');
</file>

<file path="tsconfig.base.json">
 1: {
 2:   "compilerOptions": {
 3:     "target": "ES2021",
 4:     "module": "ESNext",
 5:     "lib": ["ES2021", "DOM", "DOM.Iterable"],
 6:     "strict": true,
 7:     "moduleResolution": "Bundler",
 8:     "resolveJsonModule": true,
 9:     "esModuleInterop": true,
10:     "skipLibCheck": true,
11:     "types": ["tampermonkey"],
12:     "paths": {
13:       "@cv/core/*": ["packages/core/src/*"]
14:     }
15:   }
16: }
</file>

<file path="tsconfig.json">
 1: {
 2:   "extends": "./tsconfig.base.json",
 3:   "compilerOptions": {
 4:     "baseUrl": ".",
 5:     "paths": {
 6:       "@cv/core": ["packages/core/src/index.ts"],
 7:       "@cv/core/*": ["packages/core/src/*"]
 8:     }
 9:   }
10: }
</file>

<file path="vitest.config.ts">
1: import { defineConfig } from 'vitest/config';
2: 
3: export default defineConfig({
4:   test: {
5:     environment: 'jsdom',
6:     include: ['packages/**/test/**/*.test.ts']
7:   }
8: });
</file>

</files>
